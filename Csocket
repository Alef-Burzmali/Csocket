#ifndef _HAS_CSOCKET_
#define _HAS_CSOCKET_
#include <stdio.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/fcntl.h>
#include <sys/file.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <netdb.h>
#include <errno.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

#ifdef _HAS_SSL
#include <openssl/ssl.h>
#include <openssl/err.h>
#endif /* _HAS_SSL */

#include <Cstring>
#include <Cthreads>

// wrappers for FD_SET and such to work in templates

void TFD_ZERO( fd_set *set )
{
	FD_ZERO( set );
}

void TFD_SET( int iSock, fd_set *set )
{
	FD_SET( iSock, set );
}

bool TFD_ISSET( int iSock, fd_set *set )
{
	if ( FD_ISSET( iSock, set ) )
		return( true );
		
	return( false );
}

class Csock
{
public:
		Csock() { Csock( "", 0 ); }
		Csock( const Cstring & sHostname, int iport, int itimeout = 60 ) 
		{
#ifdef _HAS_SSL	
			m_ssl = NULL;
			m_ssl_ctx = NULL;
#endif /* _HAS_SSL */		
			m_isock = 0;
			m_itimeout = itimeout;
			m_bssl = false;
			m_bhaswrite = false;
			m_iport = iport;
			m_shostname = sHostname;
			m_bNeverWritten = true;
			m_iTcount = 0;
			m_sbuffer.clear();
		}
	
		virtual ~Csock()
		{
			close( m_isock );
#ifdef _HAS_SSL		
			if ( m_ssl )
			{
				SSL_shutdown( m_ssl );
				SSL_free( m_ssl );
			}
										
			if ( m_ssl_ctx )
				SSL_CTX_free( m_ssl_ctx );
			
			m_ssl = NULL;
			m_ssl_ctx = NULL;
#endif /* _HAS_SSL */				
		}

		typedef enum
		{
			OUTBOUND	= 0,
			LISTENER	= 1,
			INBOUND		= 2
			
		} eConnType;
		
		bool Resolve()
		{
			char hbuff[2048];
			memset( (char *)hbuff, '\0', 2048 );
			
			int err;
			
			if ( gethostbyname_r( m_shostname.c_str(), &m_hentbuff, hbuff, 2048, &m_hent, &err ) != 0 )
				return( false );
			
			return( true );
			
		}

		bool Connect()
		{
			// create the socket
			m_isock = socket( PF_INET, SOCK_STREAM, IPPROTO_TCP );
				
			m_address.sin_family = PF_INET;
			m_address.sin_port = htons( m_iport );
			m_address.sin_addr = *(struct in_addr *)m_hent->h_addr;
			
			// set it none blocking
			int fdflags = fcntl (m_isock, F_GETFL, 0);
			fcntl( m_isock, F_SETFL, fdflags|O_NONBLOCK );
			
			m_iConnType = OUTBOUND;
			
			// connect
			connect( m_isock, (struct sockaddr *)&m_address, sizeof( m_address ) );
			if ( errno != EINPROGRESS )
				return( false );
			
			return( true );
		}
		
		bool Listen( int iPort, int iMaxConns = SOMAXCONN )
		{
			m_isock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
			m_address.sin_family = PF_INET;
			m_address.sin_addr.s_addr = htonl( INADDR_ANY );
			m_address.sin_port = htons( iPort );

			if ( bind(m_isock, (struct sockaddr *) &m_address, sizeof( m_address ) ) == -1)
			{
				return( false );
			}
        
			listen( m_isock, iMaxConns );

			// set it none blocking
			int fdflags = fcntl (m_isock, F_GETFL, 0);
			fcntl( m_isock, F_SETFL, fdflags|O_NONBLOCK );

			m_iConnType = LISTENER;
		
			return( true );
		}
		
		//
		// Returns sock on success, -1 on failure
		int Accept( Cstring & sHost, int & iRPort )
		{
			struct sockaddr_in client;
			socklen_t clen;
			
			int iSock = accept( m_isock , (struct sockaddr *) &client, &clen );
			
			if ( iSock != -1 )
			{
				getpeername( iSock, (struct sockaddr *) &client, &clen );
				
				sHost = inet_ntoa( client.sin_addr );
				iRPort = ntohs( client.sin_port );
				
				ConnectionFrom( sHost, iRPort );
			}
			
			return( iSock );
		}
#ifdef _HAS_SSL
	
		bool ConnectSSL( int method = 0 )
		{
			m_bssl = true;

			SSLeay_add_ssl_algorithms();
	
			switch( method )
			{
				case 0:
					m_ssl_method = SSLv23_client_method();
					if ( !m_ssl_method )
					{
						cerr << "WARNING: MakeConnection .... SSLv23_client_method failed!" << endl;
						return( false );
					}
					break;
		
				case 2:
					m_ssl_method = SSLv2_client_method();
					if ( !m_ssl_method )
					{
						cerr << "WARNING: MakeConnection .... SSLv2_client_method failed!" << endl;
						return( false );
					}
					break;
		
				case 3:
					m_ssl_method = SSLv3_client_method();
					if ( !m_ssl_method )
					{
						cerr << "WARNING: MakeConnection .... SSLv3_client_method failed!" << endl;
						return( false );
					}		
					break;
			
				default:
					cerr << "WARNING: MakeConnection .... invalid http_sslversion version!" << endl;
					return( false );
					break;
			}

			SSL_load_error_strings ();
			// wrap some warnings in here
			m_ssl_ctx = SSL_CTX_new ( m_ssl_method );
			if ( !m_ssl_ctx )
				return( false );
			
			m_ssl = SSL_new ( m_ssl_ctx );
			if ( !m_ssl )
				return( false );
			
			SSL_set_fd( m_ssl, m_isock );
	
			if ( ( SSL_connect( m_ssl ) < 0 ) && ( errno != EAGAIN ) )
				return( false );

			return( true );
		}

		//
		// Write to the socket
		//
		bool Write( const char *data, int len )
		{
			// I know this seems silly, but if you setup string right, it can handle binary data
			// and ultimatly its easier to work with
			Cstring sSend;
			sSend.append( data, len );
			
			m_bNeverWritten = false;
#ifdef _HAS_SSL		
			if ( m_bssl )
			{
				bool bLoop = true;
				while ( bLoop )
				{
					int iErr = SSL_write( m_ssl, sSend.c_str(), sSend.length() );
					switch( SSL_get_error( m_ssl, iErr ) )
					{
						case SSL_ERROR_NONE:
						// all ok
						bLoop = false;
						break;
				
						case SSL_ERROR_ZERO_RETURN:
						// weird closer alert
						return( false );
						break;
				
						case SSL_ERROR_WANT_READ:
						// retry
						break;
				
						case SSL_ERROR_WANT_WRITE:
						// retry
						break;
					}
				}			
				return( true );
			}
#endif /* _HAS_SSL */
			while ( true )
			{
				int bytes = write( m_isock, sSend.c_str(), sSend.length() );
			
				if ( ( bytes <= 0 ) && ( errno != EAGAIN ) )
				{
					return( false );
					break;
				}
				
				if ( (unsigned int)bytes < sSend.length() )
				{
					// only able to write part, write the rest
					sSend.erase( 0, bytes );
			
				} else
					break;
			}
			
			return( true );
		}
		
		//
		// Write to the socket
		//	
		bool Write( const Cstring & sData )
		{
			return( Write( sData.c_str(), sData.length() ) );
		}

		//
		// Read from the socket
		// Just pass in a pointer, big enough to hold len bytes
		//
		// Returns 0 for EOF
		// Returns -1 for ERROR
		// Returns -2 for Try Again ( EAGAIN )
		// Otherwise returns the bytes read into data
		//
		int Read( char *data, int len )
		{
			int bytes = 0;
			memset( (char *)data, '\0', len );
			
#ifdef _HAS_SSL							
			if ( m_bssl )							
				bytes = SSL_read( m_ssl, data, len );
			else
#endif /* _HAS_SSL */							
				bytes = read( m_isock, data, len );

		    if ( bytes == -1 )
			{
				if ( ( errno == EINTR ) || ( errno == EAGAIN ) )
					return( -2 );
#ifdef _HAS_SSL
				if ( m_bssl )
				{
					int iErr = SSL_get_error( m_ssl, bytes );
					if ( ( iErr != SSL_ERROR_WANT_READ ) && ( iErr != SSL_ERROR_WANT_WRITE ) )
						return( -1 );
					else
						return( -2 );
				}
#else
				return( -1 );
#endif /* _HAS_SSL */								
			}
			
			return( bytes );
		}

		//
		// misc functions
		//				
		bool hasWrite() { return( m_bhaswrite ); }
		void setWrite( bool b ) { m_bhaswrite = b; }	
		
		int & GetSock() { return( m_isock ); }

		void ResetTimer() { m_iTcount = 0; }
		
		bool CheckTimeout()
		{
			if ( m_iTcount >= m_itimeout )
			{
				Timeout();
				return( true );
			}
									
			m_iTcount++;
			return( false );
		}
		
		bool needsWrite()
		{
			return( m_bNeverWritten );
		}
		
		void CloseSock()
		{
			// close the socket
			close( m_isock );
			// flush the buffer
			PushBuff( "\n", 1 );
			// call disconnect event
			Disconnected();
		}
		
		void PushBuff( const char *data, int len )
		{
			if ( data )
				m_sbuffer.append( data, len );
			
			while( true )
			{
				u_int iFind = m_sbuffer.find( "\n" );
			
				if ( iFind != Cstring::npos )
				{
					Cstring sBuff = m_sbuffer.substr( 0, iFind );
				
					if ( !sBuff.empty() )
						ReadLine( sBuff + "\n" );
				
					m_sbuffer.erase( 0, iFind + 1 );
				
				} else
					break;
			}
		}
		
		int GetType() { return( m_iConnType ); }
		void SetType( int iType ) { m_iConnType = iType; }
		void SetSock( int iSock ) { m_isock = iSock; }
		
		//
		// Override these functions for an easy interface
		// 
		// Connected event
		virtual void Connected() {}
		// Disconnected event
		virtual void Disconnected() {}
		// Timeout Event
		virtual void Timeout() {}
		// Jobs Event
		virtual void Jobs() {}
		// Data Ready for Read Event
		virtual void ReadData( const char *data, int len ) {}
		// Line Buffer Ready for Read Event
		virtual void ReadLine( const Cstring & sLine ) {}
		// Socket Error Event
		virtual void SockError() {}
		// Incoming Connection Event
		virtual void ConnectionFrom( const Cstring & sHost, int iPort ) {}
		//////////////////////////////////////////////////	
			
#endif /* _HAS_SSL */				
private:
		int			m_isock, m_itimeout, m_iport, m_iConnType, m_iTcount;
		bool		m_bssl, m_bhaswrite, m_bNeverWritten;
		Cstring		m_shostname, m_sbuffer;

		struct hostent		*m_hent, m_hentbuff;
		struct sockaddr_in 	m_address;
		
#ifdef _HAS_SSL
		SSL 				*m_ssl;
		SSL_CTX				*m_ssl_ctx;
		SSL_METHOD			*m_ssl_method;
#endif /* _HAS_SSL */

};

//
// new it and forget it
//
template<class T>
class TConn : public vector<T *>
{
public:
		TConn() {}
		virtual ~TConn() { m_errno = SUCCESS; }

		typedef enum
		{
			SUCCESS			= 0,
			SELECT_ERROR	= -1,
			SELECT_TIMEOUT	= -2,
			SELECT_TRYAGAIN	= -3
			
		} eMessages;

		virtual bool Connect( const Cstring & sHostname, int iPort , bool isSSL = false )
		{
			// create the new object
			T *pcSock = new T( sHostname, iPort );
			
			// figure out the hostname we're connecting to.		
			if ( !pcSock->Resolve() )
			{
				delete( pcSock );
				return( false );
			}
			
			if ( !pcSock->Connect() )
			{
				delete( pcSock );
				return( false );
			}
	
			if ( isSSL )
			{
				if ( !pcSock->ConnectSSL() )
				{
					delete( pcSock );
					return( false );
				}
			}
			
			AddSock( pcSock );
			return( true );
		}
		
		virtual bool AddListener( int iPort, int iMaxConns = SOMAXCONN )
		{
			T * pcSock = new T();
			
			if ( pcSock->Listen( iPort, iMaxConns ) )
			{
				AddSock( pcSock );
				return( true );
			}
			
			delete( pcSock );
			return( false );
		}
			
		//
		// returns a pointer to the ready Csock class thats available
		// returns NULL if none are ready, check getErr() for the error, if not SUCCESS Select() failed
		//
		
		T * Select( int iTime_sec = 1, int iTime_usec = 0 )
		{		
			struct timeval tv;
			fd_set rfds, wfds;
			
			tv.tv_sec = iTime_sec;	// one second timeout, good for clocks
			tv.tv_usec = iTime_usec;
		
			TFD_ZERO( &rfds );						
			TFD_ZERO( &wfds );
			
			bool bHasWriteable = false;
			
			for( unsigned int i = 0; i < size(); i++ )
			{
				Csock *pcSock = (*this)[i];
				
				if ( pcSock->GetType() != T::LISTENER )
				{
					int & iSock = pcSock->GetSock();

					if ( pcSock->hasWrite() )
					{
						TFD_SET( iSock, &rfds );
					
					} else
					{
						TFD_SET( iSock, &rfds );
						TFD_SET( iSock, &wfds );
						bHasWriteable = true;
					}
				} else
				{
					Cstring sHost;
					int port;
					
					int inSock = pcSock->Accept( sHost, port );
					
					if ( inSock != -1 )
					{	
						cerr << "New Connection" << endl;
						// if we have a new sock, then add it
						T * NewpcSock = new T( sHost, port );
						NewpcSock->SetType( T::INBOUND );
						NewpcSock->SetSock( inSock );
						AddSock( NewpcSock );
					}
				}
			}
			
			// now select on them
			while( true )
			{
				int iSel;
				 
				if ( bHasWriteable )
					iSel = select(FD_SETSIZE, &rfds, &wfds, NULL, &tv);
				else
					iSel = select(FD_SETSIZE, &rfds, NULL, NULL, &tv);
				
				if ( iSel == 0 )
				{
					m_errno = SELECT_TIMEOUT;
					return( NULL );
				}
				
				if ( ( iSel == -1 ) && ( errno == EINTR ) )
				{
					m_errno = SELECT_TRYAGAIN;
					return( NULL );				
				}
				
				// find out wich one is ready
				for( unsigned int i = 0; i < size(); i++ )
				{
					T *pcSock = (*this)[i];
					int & iSock = pcSock->GetSock();
						
					if ( TFD_ISSET( iSock, &rfds ) )
					{
						if ( iSel > 0 )
							m_errno = SUCCESS;
						else
							m_errno = SELECT_ERROR;
							
						return( pcSock );
						
					} else if ( TFD_ISSET( iSock, &wfds ) )
					{
						if ( iSel > 0 )
						{
							m_errno = SUCCESS;
							pcSock->setWrite( true );
							// Call the Connected Event
							pcSock->Connected();
						
						} else
							m_errno = SELECT_ERROR;

						return( pcSock );
					}

				}
				// it said one was ready, but none of them were :(
				m_errno = SELECT_ERROR;	
				return( NULL );
			}
			
			return( NULL );
		}			
				
		void DelSock( T *pcSock )
		{
			iterator p;
			
			for( unsigned int i = 0; i < size(); i++ )
			{
				if ( (*this)[i] == pcSock )
				{
					p = this->begin() + i;
					delete( (*this)[i] );
					this->erase( p );
					return;
				}
			}
			cerr << "WARNING!!! Could not find " << (unsigned int *)pcSock << endl;
		}


		//
		// Best place to call this class for running, all the call backs are called
		// You should through this in your main while loop (long as its not blocking)
		// 
		void Loop ()
		{
			T *pcSock = Select();
			
			switch( m_errno )
			{
				case SUCCESS:
				{
					pcSock->ResetTimer();	// reset the timeout timer
					
					// read in data
					char buff[64];
					int bytes = pcSock->Read( buff, 64 );

					switch( bytes )
					{
						case 0:
						{
							// EOF
							pcSock->CloseSock();
							DelSock( pcSock );
							break;
						}
						
						case -1:
						{
							pcSock->SockError();
							pcSock->CloseSock();
							DelSock( pcSock );
							break;
						}
						
						case -2:
							break;
							
						default:
						{
							pcSock->PushBuff( buff, bytes );
							pcSock->ReadData( buff, bytes );
							break;
						}								
					}
					break;
				}
			
				case SELECT_ERROR:
				{
					// a socket came back with an error
					// usually means it was closed
					close( pcSock->GetSock() );
					DelSock( pcSock );
					break;
				}
				case SELECT_TIMEOUT:
				{
					// call timeout on all the sockets
					for( unsigned int i = 0; i < size(); i++ )
					{
						if ( (*this)[i]->GetType() == T::LISTENER )
							break;
							
						(*this)[i]->Jobs();
						if ( (*this)[i]->CheckTimeout() )
						{
							// socket timeout, close the socket
							(*this)[i]->CloseSock();
						}
					}
					break;
				}
				
				default	:
					break;
			}
		}

		void AddSock( T *pcSock )
		{
			push_back( pcSock );
		}
				
		int GetErrno() { return( m_errno ); }
private:

		int			m_errno;
};

#endif /* _HAS_CSOCKET_ */