#ifndef _HAS_CSOCKET_
#define _HAS_CSOCKET_
#include <stdio.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/fcntl.h>
#include <sys/file.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <netdb.h>
#include <errno.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>
#include <sys/ioctl.h>
#include <sys/timeb.h>

#ifdef HAVE_LIBSSL
#include <openssl/ssl.h>
#include <openssl/err.h>
#endif /* HAVE_LIBSSL */

#include "Cstring"
#include "Cthreads"

// wrappers for FD_SET and such to work in templates
inline void TFD_ZERO( fd_set *set )
{
	FD_ZERO( set );
}

inline void TFD_SET( int iSock, fd_set *set )
{
	FD_SET( iSock, set );
}

inline bool TFD_ISSET( int iSock, fd_set *set )
{
	if ( FD_ISSET( iSock, set ) )
		return( true );
		
	return( false );
}

inline void TFD_CLR( int iSock, fd_set *set )
{
	FD_CLR( iSock, set );
}

//
// Cronjob class
// To create a job, derive from this class, override RunJob with your code
// add it to the Csock class with AddCron()
//
class CCron
{
public:
		CCron() 
		{
			m_bOnlyOnce = true;
			m_bActive = true;
			m_iTime	= 0;
			m_iTimeSequence = 60;
		}
		virtual ~CCron() {}
		
		void run() 
		{
			if ( ( m_bActive ) && ( time( NULL ) >= m_iTime ) )
			{
			
				RunJob();

				if ( m_bOnlyOnce )
					m_bActive = false;
				else
					m_iTime = time( NULL ) + m_iTimeSequence;
			}
		}
		
		void Start( int TimeSequence, bool bOnlyOnce = true ) 
		{
			m_iTimeSequence = TimeSequence;
			m_iTime = time( NULL ) + m_iTimeSequence;
			m_bOnlyOnce = bOnlyOnce;
		}

		void Stop()
		{
			m_bActive = false;
		}

		bool isValid() { return( m_bActive ); }
		
protected:

		virtual void RunJob()
		{
			cerr << "Override me." << endl;
			// override me
		}
		
		time_t	m_iTime;
		bool	m_bOnlyOnce, m_bActive;
		int		m_iTimeSequence;
};

//
// Basic Socket Class
// The most basic level socket class
// You can use this class directly for quick things
// or use the socket manager below
//

class Csock
{
public:
		Csock( int itimeout = 60 ) 
		{ 
			Init( "", 0, itimeout ); 
		}
		Csock( const Cstring & sHostname, int iport, int itimeout = 60 ) 
		{
			Init( sHostname, iport, itimeout );
		}
		
		virtual ~Csock()
		{
			close( m_isock );
#ifdef HAVE_LIBSSL
			FREE_SSL();
			FREE_CTX();

#endif /* HAVE_LIBSSL */				
			// delete any left over crons
			for( unsigned int i = 0; i < m_vcCrons.size(); i++ )
				Zzap( m_vcCrons[i] );
		}

		typedef enum
		{
			OUTBOUND	= 0,		// outbound connection
			LISTENER	= 1,		// a socket accepting connections
			INBOUND		= 2			// an inbound connection, passed from LISTENER
			
		} eConnType;
		
		typedef enum
		{
			READ_EOF	= 0,		// End Of File, done reading
			READ_ERR	= -1,		// Error on the socket, socket closed, done reading
			READ_EAGAIN	= -2		// Try to get data again
			
		} eReadFlags;
		
		typedef enum
		{
			SEL_OK		= 0,
			SEL_TIMEOUT	= -1,
			SEL_EAGAIN	= -2,
			SEL_ERR		= -3
		
		} eSelectFlags;
		
		typedef enum
		{
			SSL23	= 0,
			SSL2	= 2,
			SSL3	= 3
		
		} eSSLMethods;

		//
		// stream operators
		Csock & operator<<( const Cstring & s ) 
		{
			Write( s );
			return( *this );
		}
		Csock & operator<<( ostream & ( *io )( ostream & ) )
		{
			Write( "\n" );
			return( *this );
		}			
		Csock & operator<<( int i ) 
		{
			Write( Cstring::num2Cstring( i ) );
			return( *this );
		}
		Csock & operator<<( unsigned int i ) 
		{
			Write( Cstring::num2Cstring( i ) );
			return( *this );
		}
		Csock & operator<<( long i ) 
		{ 
			Write( Cstring::num2Cstring( i ) );
			return( *this );
		}
		Csock & operator<<( unsigned long i ) 
		{
			Write( Cstring::num2Cstring( i ) );
			return( *this );
		}
		Csock & operator<<( unsigned long long i ) 
		{
			Write( Cstring::num2Cstring( i ) );
			return( *this );
		}
		Csock & operator<<( float i ) 
		{
			Write( Cstring::num2Cstring( i ) );
			return( *this );
		}
		Csock & operator<<( double i ) 
		{
			Write( Cstring::num2Cstring( i ) );
			return( *this );
		}		
		//
		// Resolve the name into m_hent
		//
		bool Resolve()
		{
			char hbuff[2048];
			memset( (char *)hbuff, '\0', 2048 );
			
#ifdef __linux__			
			int err;
			if ( gethostbyname_r( m_shostname.c_str(), &m_hentbuff, hbuff, 2048, &m_hent, &err ) != 0 )
				return( false );
#endif /* __linux__ */
#if defined(__FreeBSD__) || defined(__sun)
			m_hent = gethostbyname( m_shostname.c_str() );
			if ( !m_hent )
				return( false );
#endif /* __FreeBSD__ || __sun */
			
			return( true );
			
		}

		//
		// connect to a host
		//
		bool Connect( const Cstring & sBindHost = "" )
		{
			// create the socket
			m_isock = SOCKET();
				
			if ( !m_hent )
				if ( !Resolve() )
					return( false );
					
			m_address.sin_family = PF_INET;
			m_address.sin_port = htons( m_iport );
			m_address.sin_addr = *(struct in_addr *)m_hent->h_addr;

			// bind to a hostname if requested
			if ( !sBindHost.empty() )
			{
				struct sockaddr_in vh;
				struct hostent *h = gethostbyname( sBindHost.c_str() );
				
				if ( h )
				{
					vh.sin_family = PF_INET;
					vh.sin_addr = *(struct in_addr *)h->h_addr;
					bind( m_isock, (struct sockaddr *) &vh, sizeof( vh ) );
				}
			}
			
			// set it none blocking
			int fdflags = fcntl (m_isock, F_GETFL, 0);
			fcntl( m_isock, F_SETFL, fdflags|O_NONBLOCK );

			m_iConnType = OUTBOUND;
			
			// connect
			int ret = connect( m_isock, (struct sockaddr *)&m_address, sizeof( m_address ) );

			if ( ( ret == -1 ) && ( errno != EINPROGRESS ) )
				return( false );

			if ( m_bBLOCK )
			{	
				// unset the flags afterwords, rather than have connect block
				int fdflags = fcntl (m_isock, F_GETFL, 0); 
				
				if ( O_NONBLOCK & fdflags )
					fdflags -= O_NONBLOCK;
					
				fcntl( m_isock, F_SETFL, fdflags );
				
			}
			
			return( true );
		}
		
		//
		// WriteSelect on this socket
		// Only good if JUST using this socket, otherwise use the parent class below
		int WriteSelect()
		{
			struct timeval tv;
			fd_set wfds;

			TFD_ZERO( &wfds );
			TFD_SET( m_isock, &wfds );
			
			tv.tv_sec = m_itimeout;
			tv.tv_usec = 0;

			int ret = select( FD_SETSIZE, NULL, &wfds, NULL, &tv );

			if ( ret == 0 )
				return( SEL_TIMEOUT );
		
			if ( ret == -1 )
			{
				if ( errno == EINTR )
					return( SEL_EAGAIN );
				else
					return( SEL_ERR );
			}
			
			return( SEL_OK );
		}

		//
		// ReadSelect on this socket
		// Only good if JUST using this socket, otherwise use the parent class below
		int ReadSelect()
		{
			struct timeval tv;
			fd_set rfds;

			TFD_ZERO( &rfds );
			TFD_SET( m_isock, &rfds );

			tv.tv_sec = m_itimeout;
			tv.tv_usec = 0;
			
			int ret = select( FD_SETSIZE, &rfds, NULL, NULL, &tv );
			
			if ( ret == 0 )
				return( SEL_TIMEOUT );
		
			if ( ret == -1 )
			{
				if ( errno == EINTR )
					return( SEL_EAGAIN );
				else
					return( SEL_ERR );
			}
			
			return( SEL_OK );
		}		
		//
		//
		// Listens for connections
		//
		bool Listen( int iPort, int iMaxConns = SOMAXCONN )
		{
			m_isock = SOCKET( true );

			if ( m_isock == -1 )
				return( false );

			m_address.sin_family = PF_INET;
			m_address.sin_addr.s_addr = htonl( INADDR_ANY );
			m_address.sin_port = htons( iPort );

			if ( bind(m_isock, (struct sockaddr *) &m_address, sizeof( m_address ) ) == -1 )
			{
				return( false );
			}
        
			if ( listen( m_isock, iMaxConns ) == -1 )
				return( false );

			if ( !m_bBLOCK )
			{
				// set it none blocking
				int fdflags = fcntl (m_isock, F_GETFL, 0);
				fcntl( m_isock, F_SETFL, fdflags|O_NONBLOCK );
			}
			
			m_iConnType = LISTENER;
			return( true );
		}
		
		//
		// Returns sock on success, -1 on failure
		//
		int Accept( Cstring & sHost, int & iRPort )
		{
			struct sockaddr_in client;
			socklen_t clen = sizeof(struct sockaddr);
			
			int iSock = accept( m_isock , (struct sockaddr *) &client, &clen );
			
			if ( iSock != -1 )
			{
				if ( !m_bBLOCK )
				{
					// make it none blocking
					int fdflags = fcntl (iSock, F_GETFL, 0);
					fcntl( iSock, F_SETFL, fdflags|O_NONBLOCK );
				}
				
				getpeername( iSock, (struct sockaddr *) &client, &clen );
				
				sHost = inet_ntoa( client.sin_addr );
				iRPort = ntohs( client.sin_port );

				ConnectionFrom( sHost, iRPort );

			}
			
			return( iSock );
		}
		
		bool AcceptSSL()
		{
#ifdef HAVE_LIBSSL
			if ( !m_ssl )
				if ( !SSLServerSetup() )
					return( false );
				
			
			int err = SSL_accept( m_ssl );

			if ( err == 1 )
			{
				m_bFullsslAccept = true;
				return( true );				
			}

			m_bFullsslAccept = false;

			int sslErr = SSL_get_error( m_ssl, err );

			if ( ( sslErr == SSL_ERROR_WANT_READ ) || ( sslErr == SSL_ERROR_WANT_WRITE ) )
				return( true );

			ERR_print_errors_fp ( stderr );
			
#endif /* HAVE_LIBSSL */
			
			return( false );	
		}

		bool SSLClientSetup()
		{
#ifdef HAVE_LIBSSL		
			m_bssl = true;
			FREE_SSL();
			FREE_CTX();

			SSLeay_add_ssl_algorithms();
	
			switch( m_iMethod )
			{
				case 0:
					m_ssl_method = SSLv23_client_method();
					if ( !m_ssl_method )
					{
						cerr << "WARNING: MakeConnection .... SSLv23_client_method failed!" << endl;
						return( false );
					}
					break;
		
				case 2:
					m_ssl_method = SSLv2_client_method();
					if ( !m_ssl_method )
					{
						cerr << "WARNING: MakeConnection .... SSLv2_client_method failed!" << endl;
						return( false );
					}
					break;
		
				case 3:
					m_ssl_method = SSLv3_client_method();
					if ( !m_ssl_method )
					{
						cerr << "WARNING: MakeConnection .... SSLv3_client_method failed!" << endl;
						return( false );
					}		
					break;
			
				default:
					cerr << "WARNING: MakeConnection .... invalid http_sslversion version!" << endl;
					return( false );
					break;
			}

			SSL_load_error_strings ();
			// wrap some warnings in here
			m_ssl_ctx = SSL_CTX_new ( m_ssl_method );
			if ( !m_ssl_ctx )
				return( false );
			
			m_ssl = SSL_new ( m_ssl_ctx );
			if ( !m_ssl )
				return( false );
			
			SSL_set_fd( m_ssl, m_isock );
			
			return( true );
#else
			return( false );
			
#endif /* HAVE_LIBSSL */		
		}

		bool SSLServerSetup()
		{
#ifdef HAVE_LIBSSL
			m_bssl = true;
			FREE_SSL();			
			FREE_CTX();
					
			SSLeay_add_ssl_algorithms();
	
			switch( m_iMethod )
			{
				case 0:
					m_ssl_method = SSLv23_server_method();
					if ( !m_ssl_method )
					{
						cerr << "WARNING: MakeConnection .... SSLv23_server_method failed!" << endl;
						return( false );
					}
					break;
		
				case 2:
					m_ssl_method = SSLv2_server_method();
					if ( !m_ssl_method )
					{
						cerr << "WARNING: MakeConnection .... SSLv2_server_method failed!" << endl;
						return( false );
					}
					break;
		
				case 3:
					m_ssl_method = SSLv3_server_method();
					if ( !m_ssl_method )
					{
						cerr << "WARNING: MakeConnection .... SSLv3_server_method failed!" << endl;
						return( false );
					}		
					break;
			
				default:
					cerr << "WARNING: MakeConnection .... invalid http_sslversion version!" << endl;
					return( false );
					break;
			}

			SSL_load_error_strings ();
			// wrap some warnings in here
			m_ssl_ctx = SSL_CTX_new ( m_ssl_method );
			if ( !m_ssl_ctx )
				return( false );
			
			if ( ( m_sPemFile.empty() ) || ( access( m_sPemFile.c_str(), R_OK ) != 0 ) )
			{
				cerr << "There is a problem with [" << m_sPemFile << "]" << endl;
				return( false );
			}

			//
			// set up the CTX
			if ( SSL_CTX_use_certificate_file( m_ssl_ctx, m_sPemFile.c_str() , SSL_FILETYPE_PEM ) <= 0 )
			{
				cerr << "Error with PEM file [" << m_sPemFile << "]" << endl;
				ERR_print_errors_fp ( stderr );
				return( false );
			}
			
			if ( SSL_CTX_use_PrivateKey_file( m_ssl_ctx, m_sPemFile.c_str(), SSL_FILETYPE_PEM ) <= 0 )
			{
				cerr << "Error with PEM file [" << m_sPemFile << "]" << endl;
				ERR_print_errors_fp ( stderr );
				return( false );
			}
			
			if ( SSL_CTX_set_cipher_list( m_ssl_ctx, m_sCipherType.c_str() ) <= 0 )
			{
				cerr << "Could not assign cipher [" << m_sCipherType << "]" << endl;
				return( false );
			}

			//
			// setup the SSL
			m_ssl = SSL_new ( m_ssl_ctx );
			if ( !m_ssl )
				return( false );
			
			SSL_set_fd( m_ssl, m_isock );
			SSL_set_accept_state( m_ssl );
			
			return( true );
#else
			return( false );
#endif /* HAVE_LIBSSL */		
		}		
		
		bool ConnectSSL( const Cstring & sBindhost = "" )
		{
#ifdef HAVE_LIBSSL		
			if ( m_isock == 0 )
				if ( !Connect( sBindhost ) )
					return( false );

			if ( !m_ssl )
				if ( !SSLClientSetup() )
					return( false );
				
			bool bPass = true;
			
			if ( m_bBLOCK )
			{
				int fdflags = fcntl (m_isock, F_GETFL, 0);
				fcntl( m_isock, F_SETFL, fdflags|O_NONBLOCK );
			}	
			
			if ( ( SSL_connect( m_ssl ) < 0 ) && ( errno != EAGAIN ) )
				bPass = false;

			if ( m_bBLOCK )
			{	
				// unset the flags afterwords, rather then have connect block
				int fdflags = fcntl (m_isock, F_GETFL, 0); 
				
				if ( O_NONBLOCK & fdflags )
					fdflags -= O_NONBLOCK;
					
				fcntl( m_isock, F_SETFL, fdflags );
				
			}				
			
			return( bPass );
#else
			return( false );
#endif /* HAVE_LIBSSL */
		}


		//
		// Write to the socket
		//
		bool Write( const char *data, int len )
		{
			m_sSend.append( data, len );

			if ( m_sSend.empty() )
			{
#ifdef _DEBUG_
				// maybe eventually make a __DEBUG_ONLY()
				cerr << "ER, NOT Sending DATA!? [" << GetSockName() << "]" << endl;
#endif /* _DEBUG_ */
				return( true );
			}
			
			if ( m_bBLOCK )
			{
				if ( WriteSelect() != SEL_OK )
					return( false );

			}
			// rate shaping
			u_int iBytesToSend = 0;
			
			if ( ( m_iMaxBytes > 0 ) && ( m_iMaxMilliSeconds > 0 ) )
			{
				unsigned long long iNOW = GetMillTime();
				// figure out the shaping here				
				// if NOW - m_iLastSendTime > m_iMaxMilliSeconds then send a full length of ( iBytesToSend )
				if ( ( iNOW - m_iLastSendTime ) > m_iMaxMilliSeconds )
				{
					m_iLastSendTime = iNOW;
					iBytesToSend = m_iMaxBytes;
					m_iLastSend = 0;
				
				} else // otherwise send m_iMaxBytes - m_iLastSend
					iBytesToSend = m_iMaxBytes - m_iLastSend;

				// take which ever is lesser
				if ( m_sSend.length() < iBytesToSend )
					iBytesToSend = 	m_sSend.length();
								
				// add up the bytes sent
				m_iLastSend += iBytesToSend;
				
				// so, are we ready to send anything ?
				if ( iBytesToSend == 0 )
					return( true );

			//cerr << "RATE SHAPING, only sending " << iBytesToSend << " bytes!" << endl;	
			} else
				iBytesToSend = m_sSend.length();
				
			m_bNeverWritten = false;
#ifdef HAVE_LIBSSL	
			if ( m_bssl )
			{
				int iErr = SSL_write( m_ssl, m_sSend.c_str(), iBytesToSend );
				switch( SSL_get_error( m_ssl, iErr ) )
				{
					case SSL_ERROR_NONE:
					// all ok
					break;
				
					case SSL_ERROR_ZERO_RETURN:
					// weird closer alert
					return( false );
					break;
				
					case SSL_ERROR_WANT_READ:
					// retry
					break;
				
					case SSL_ERROR_WANT_WRITE:
					// retry
					break;
						
					case SSL_ERROR_SSL:
					return( false );
					break;
				}

				if ( iErr > 0 )				
					m_sSend.erase( 0, iErr );
				
				return( true );
			}
#endif /* HAVE_LIBSSL */
			int bytes = write( m_isock, m_sSend.c_str(), iBytesToSend );
		
			if ( ( bytes <= 0 ) && ( errno != EAGAIN ) )
				return( false );
			
			// delete the bytes we sent
			if ( bytes > 0 )
				m_sSend.erase( 0, bytes );

			return( true );
		}
		
		//
		// Write to the socket
		//	
		bool Write( const Cstring & sData )
		{
			return( Write( sData.c_str(), sData.length() ) );
		}

		//
		// Read from the socket
		// Just pass in a pointer, big enough to hold len bytes
		//
		// Returns READ_EOF for EOF
		// Returns READ_ERR for ERROR
		// Returns READ_EAGAIN for Try Again ( EAGAIN )
		// Otherwise returns the bytes read into data
		//
		int Read( char *data, int len )
		{
	
			if ( m_bBLOCK )
			{
				if ( ReadSelect() != SEL_OK )
					return( READ_ERR );
			}
			
			int bytes = 0;
			memset( (char *)data, '\0', len );
			
#ifdef HAVE_LIBSSL
			if ( m_bssl )
				bytes = SSL_read( m_ssl, data, len );
			else
#endif /* HAVE_LIBSSL */
				bytes = read( m_isock, data, len );

		    if ( bytes == -1 )
			{
				if ( ( errno == EINTR ) || ( errno == EAGAIN ) )
					return( READ_EAGAIN );
#ifdef HAVE_LIBSSL
				if ( m_bssl )
				{
					int iErr = SSL_get_error( m_ssl, bytes );
					if ( ( iErr != SSL_ERROR_WANT_READ ) && ( iErr != SSL_ERROR_WANT_WRITE ) )
						return( READ_ERR );
					else
						return( READ_EAGAIN );
				}
#else
				return( READ_ERR );
#endif /* HAVE_LIBSSL */								
			}
			
			return( bytes );
		}

		//
		// misc functions
		//
		// Tells you if the socket is ready for write.
		bool hasWrite() { return( m_bhaswrite ); }
		void setWrite( bool b ) { m_bhaswrite = b; }	

		//
		// has never been written too, you can easy use the two to find a first case scenario
		// if ( ( hasWrite() ) && ( !needsWrite() ) )
		//		first time write
		//
		
		bool needsWrite()
		{
			return( m_bNeverWritten );
		}

		//
		// returns a reference to the sock
		int & GetSock() { return( m_isock ); }
		void SetSock( int iSock ) { m_isock = iSock; }
		
		//
		// resets the time counter
		void ResetTimer() { m_iTcount = 0; }
		
		//
		// this timeout isn't just connection timeout, but also timeout on
		// NOT recieving data, to disable this set it to 0
		// then the normal TCP timeout will apply (basically TCP will kill a dead connection)
		// Set the timeout, set to 0 to never timeout
		void SetTimeout( int iTimeout ) { m_itimeout = iTimeout; }
		
		//
		// returns true if the socket has timed out
		bool CheckTimeout()
		{
			if ( m_itimeout > 0 )
			{
				if ( ( m_iTcount / 4 ) >= m_itimeout )
				{
					Timeout();
					return( true );
				}
									
				m_iTcount++;	// since the select statement is in 1/4 second timeouts, increment them by four
			
			}	
			return( false );
		}
		
		//
		// pushes data up on the buffer, if a line is ready
		// it calls the ReadLine event
		void PushBuff( const char *data, int len )
		{
			if ( data )
				m_sbuffer.append( data, len );
			
			while( true )
			{
				u_int iFind = m_sbuffer.find( "\n" );
			
				if ( iFind != Cstring::npos )
				{
					Cstring sBuff = m_sbuffer.substr( 0, iFind );
					m_sbuffer.erase( 0, iFind + 1 );

					if ( !sBuff.empty() )
						ReadLine( sBuff + "\n" );				

				} else
					break;
			}
		}
		
		//
		// Returns the connection type from enum eConnType
		int GetType() { return( m_iConnType ); }
		void SetType( int iType ) { m_iConnType = iType; }
		
		//
		// Returns a reference to the socket name
		const Cstring & GetSockName() { return( m_sSockName ); }
		void SetSockName( const Cstring & sName ) { m_sSockName = sName; }
		
		//
		// Returns a reference to the host name
		const Cstring & GetHostName() { return( m_shostname ); }
		 
		// Returns the port
		int GetPort() { return( m_iport ); }
		
		// just mark us as closed, the parent can pick it up
		void Close() { m_bClosed = true; }
		// returns true if the socket is closed
		bool isClosed() { return( m_bClosed ); }
		
		//
		// Set rather to NON Blocking IO on this socket, default is true
		void BlockIO( bool bBLOCK ) { m_bBLOCK = bBLOCK; }

		//
		// if this connection type is ssl or not
		bool GetSSL() { return( m_bssl ); }
		void SetSSL( bool b ) { m_bssl = b; }
		
		//
		// Set the cipher type ( openssl cipher [to see ciphers available] )
		void SetCipher( const Cstring & sCipher ) { m_sCipherType = sCipher; }
		const Cstring & GetCipher() { return( m_sCipherType ); }
		
		//
		// Set the pem file location
		void SetPemLocation( const Cstring & sPemFile ) { m_sPemFile = sPemFile; }
		const Cstring & GetPemLocation() { return( m_sPemFile ); }
		
		//
		// Set the SSL method type
		void SetSSLMethod( int iMethod ) { m_iMethod = iMethod; }
		int GetSSLMethod() { return( m_iMethod ); }
		
		//
		// Get the send buffer
		const Cstring & GetSendBuff() { return( m_sSend ); }

		//
		// is SSL_accept finished ?
		bool FullSSLAccept() { return ( m_bFullsslAccept ); }
		//
		// Get the peer's X509 cert
#ifdef HAVE_LIBSSL
		X509 *getX509()
		{
			if ( m_ssl )
				return( SSL_get_peer_certificate( m_ssl ) );

			return( NULL );
		}
#endif /* HAVE_LIBSSL */

		//
		// Set The INBOUND Parent sockname
		void SetParentSockName( const Cstring & sParentName ) { m_sParentName = sParentName; }
		const Cstring & GetParentSockName() { return( m_sParentName ); }
		
		void SetRate( u_int iBytes, unsigned long long iMilliseconds )
		{
			m_iMaxBytes = iBytes;
			m_iMaxMilliSeconds = iMilliseconds;
		}
		
		//
		// Cron caller
		// Once we have the cron, we'll delete it
		void Cron()
		{
			vector<CCron *>::iterator p = m_vcCrons.begin();

			while( true )
			{
				if ( p == m_vcCrons.end() )
					break;
					
				CCron *pcCron = *p;

				if ( !pcCron->isValid() )
				{
					Zzap( pcCron );
					m_vcCrons.erase( p );
					// start from the beginning again
					p = m_vcCrons.begin();
					
				} else
				{
					pcCron->run();
					p++;
				}
			}
		}
		
		//
		// Insert the cronjob
		// 
		void AddCron( CCron * pcCron )
		{
			m_vcCrons.push_back( pcCron );
		}
				
		//
		// Override these functions for an easy interface when using the Socket Manager
		// Don't bother using these callbacks if you are using this class directly (without Socket Manager)
		// as the Socket Manager calls most of these callbacks
		// Connected event
		virtual void Connected() {}
		// Disconnected event
		virtual void Disconnected() {}
		// Timeout
		virtual void Timeout() {}
		// Data Ready for Read Event
		virtual void ReadData( const char *data, int len ) {}
		// Line Buffer Ready for Read Event
		virtual void ReadLine( const Cstring & sLine ) {}
		// Socket Error Event
		virtual void SockError() {}
		// Incoming Connection Event
		virtual void ConnectionFrom( const Cstring & sHost, int iPort ) {}
		//////////////////////////////////////////////////	
			
				
private:
		int			m_isock, m_itimeout, m_iport, m_iConnType, m_iTcount, m_iMethod;
		bool		m_bssl, m_bhaswrite, m_bNeverWritten, m_bClosed, m_bBLOCK, m_bFullsslAccept;
		Cstring		m_shostname, m_sbuffer, m_sSockName, m_sPemFile, m_sCipherType, m_sParentName;
		Cstring		m_sSend;

		unsigned long long	m_iMaxMilliSeconds, m_iLastSendTime;
		unsigned int		m_iMaxBytes, m_iLastSend;
		
		struct hostent		*m_hent, m_hentbuff;
		struct sockaddr_in 	m_address;
		
#ifdef HAVE_LIBSSL
		SSL 				*m_ssl;
		SSL_CTX				*m_ssl_ctx;
		SSL_METHOD			*m_ssl_method;

		void FREE_SSL()
		{
			if ( m_ssl )
			{
				SSL_shutdown( m_ssl );
				SSL_free( m_ssl );
			}
			m_ssl = NULL;
		}

		void FREE_CTX()
		{
			if ( m_ssl_ctx )
				SSL_CTX_free( m_ssl_ctx );

			m_ssl_ctx = NULL;
		}

#endif /* HAVE_LIBSSL */

		vector<CCron *>		m_vcCrons;


		int SOCKET( bool bListen = false )
		{
			int iRet = 0;
			while( iRet == 0 )
				iRet = socket( PF_INET, SOCK_STREAM, IPPROTO_TCP );
			
			if ( ( iRet > -1 ) && ( bListen ) )
			{
				const int on = 1;

                        	if ( setsockopt( iRet, SOL_SOCKET, SO_REUSEADDR, &on, sizeof( on ) ) != 0 )
				{
					cerr << "SOCKET: Could not set SO_REUSEADDR" << endl;
				}
			}

			return( iRet );
		}

		void Init( const Cstring & sHostname, int iport, int itimeout = 60 )
		{
#ifdef HAVE_LIBSSL	
			m_ssl = NULL;
			m_ssl_ctx = NULL;
#endif /* HAVE_LIBSSL */		
			m_isock = 0;
			m_itimeout = itimeout;
			m_bssl = false;
			m_bhaswrite = false;
			m_iport = iport;
			m_shostname = sHostname;
			m_bNeverWritten = true;
			m_iTcount = 0;
			m_sbuffer.clear();
			m_bClosed = false;
			m_bBLOCK = true;
			m_hent = NULL;
			m_iMethod = SSL23;
			m_sCipherType = "ALL";
			m_sPemFile = "server.pem";
			m_iMaxBytes = 0;
			m_iMaxMilliSeconds = 0;
			m_iLastSendTime = 0;
			m_iLastSend = 0;
			m_bFullsslAccept = false;
		}
		
		unsigned long long GetMillTime()
		{
			struct timeb tp;
			unsigned long long iTime = 0;
			ftime( &tp );
			iTime = tp.time * 1000;
			iTime += tp.millitm;			
			return( iTime );
		}
		
};

//
// TSocketManager
// Best class to use to interact with the sockets
// handles SSL and NON Blocking IO
// Its a template class since Csock derives need to be new'd correctly
// Makes it easier to use overall
// Rather then use it directly, you'll probably get more use deriving from it
//
// class CBlahSock : public TSocketManager<SomeSock>
//

template<class T>
class TSocketManager : public vector<T *>
{
public:
		TSocketManager() { m_errno = SUCCESS; }
		virtual ~TSocketManager() 
		{
			for( unsigned int i = 0; i < size(); i++ )
				if ( (*this)[i] )
					Zzap( (*this)[i] );

		}

		typedef enum
		{
			SUCCESS			= 0,	// Select returned more then 1 fd ready for action
			SELECT_ERROR	= -1,	// An Error Happened, Probably dead socket. That socket is returned if available
			SELECT_TIMEOUT	= -2,	// Select Timeout
			SELECT_TRYAGAIN	= -3	// Select calls for you to try again
			
		} eMessages;

		bool Connect( const Cstring & sHostname, int iPort , const Cstring & sSockName, int iTimeout = 60, bool isSSL = false, const Cstring & sBindHost = "" )
		{
			// create the new object
			T *pcSock = new T( sHostname, iPort, iTimeout );
			
			// make it NON-Blocking IO
			pcSock->BlockIO( false );
			
			// figure out the hostname we're connecting to.		
			if ( !pcSock->Resolve() )
			{
				Zzap( pcSock );
				return( false );
			}
			
			if ( !pcSock->Connect( sBindHost ) )
			{
				Zzap( pcSock );
				return( false );
			}
	
#ifdef HAVE_LIBSSL
			if ( isSSL )
			{
				if ( !pcSock->ConnectSSL() )
				{
					Zzap( pcSock );
					return( false );
				}
			}
#endif /* HAVE_LIBSSL */
			
			AddSock( pcSock, sSockName );
			return( true );
		}

		bool QuickConnect( const Cstring & sHostname, int iPort, int iTimeout = 60 )
		{
			return( Connect( sHostname, iPort, "QuickConnect", iTimeout ) );
		}

		bool QuickSSLConnect( const Cstring & sHostname, int iPort, int iTimeout = 60 )
		{
#ifdef HAVE_LIBSSL		
			return( Connect( sHostname, iPort, "QuickConnect", iTimeout, true ) );
#else
			return( false );
#endif /* HAVE_LIBSSL */
		}		

		bool AddListener( int iPort, const Cstring & sSockName, int isSSL = false, int iMaxConns = SOMAXCONN )
		{
			T * pcSock = new T();

			pcSock->BlockIO( false );

			pcSock->SetSSL( isSSL );

			if ( pcSock->Listen( iPort, iMaxConns ) )
			{
				AddSock( pcSock, sSockName );
				return( true );
			}
			Zzap( pcSock );
			return( false );
		}
			
		//
		// returns a pointer to the ready Csock class thats available
		// returns NULL if none are ready, check GetErrno() for the error, if not SUCCESS Select() failed
		//
		
		T * Select()
		{		
			struct timeval tv;
			fd_set rfds, wfds;
			
			// 1/4 second timeouts, nice and easy
			// if you decide to change this number, be sure to change the
			// timeout counter above, or your timeouts will be off
			// ( m_iTCount in Csock class )
			tv.tv_sec = 0;
			tv.tv_usec = ( 1000000 / 4 ); 
		
			TFD_ZERO( &rfds );						
			TFD_ZERO( &wfds );

			// before we go any further, Process work needing to be done on the job

			for( unsigned int i = 0; i < size(); i++ )
			{

				if ( (*this)[i]->isClosed() )
				{
					if ( (*this)[i]->GetType() == T::LISTENER )
						cerr << "Closing Listener" << endl;

					DestroySock( (*this)[i] );
				} else
				{
					// call the Cron handler here
					(*this)[i]->Cron();
				}
			}

			for( unsigned int i = 0; i < m_pcDestroySocks.size(); i++ )
				DelSock( m_pcDestroySocks[i] );

			m_pcDestroySocks.clear();
			
			// on with the show
			
			bool bHasWriteable = false;

			for( unsigned int i = 0; i < size(); i++ )
			{

				Csock *pcSock = (*this)[i];
				
				if ( pcSock->GetType() != T::LISTENER )
				{
					int & iSock = pcSock->GetSock();

					if ( ( pcSock->GetSSL() ) && ( pcSock->GetType() == T::INBOUND ) && ( !pcSock->FullSSLAccept() ) )
					{
						// try accept on this socket again
						if ( !pcSock->AcceptSSL() )
							pcSock->Close();

					} else if ( ( pcSock->hasWrite() ) && ( pcSock->GetSendBuff().empty() ) )
					{
						TFD_SET( iSock, &rfds );
					
					} else
					{
						TFD_SET( iSock, &rfds );
						TFD_SET( iSock, &wfds );
						bHasWriteable = true;
					}
				} else
				{
					Cstring sHost;
					int port;
					int inSock = pcSock->Accept( sHost, port );
					
					if ( inSock != -1 )
					{
						// if we have a new sock, then add it
						T * NewpcSock = new T( sHost, port );
						
						NewpcSock->BlockIO( false );
						
						NewpcSock->SetType( T::INBOUND );
						NewpcSock->SetSock( inSock );
						
						bool bAddSock = true;
#ifdef HAVE_LIBSSL						
						//
						// is this ssl ?
						if ( pcSock->GetSSL() )
						{
							NewpcSock->SetCipher( pcSock->GetCipher() );
							NewpcSock->SetPemLocation( pcSock->GetPemLocation() );
							bAddSock = NewpcSock->AcceptSSL();
						}
								
#endif /* HAVE_LIBSSL */
						if ( bAddSock )
						{
							// set the name of the listener
							NewpcSock->SetParentSockName( pcSock->GetSockName() );
							AddSock( NewpcSock,  sHost + ":" + Cstring::num2Cstring( port ) );
						
						} else
							Zzap( NewpcSock );
					}
				}
			}
		
			// now select on them
			while( true )
			{
				int iSel;

				if ( bHasWriteable )
					iSel = select(FD_SETSIZE, &rfds, &wfds, NULL, &tv);
				else
					iSel = select(FD_SETSIZE, &rfds, NULL, NULL, &tv);

				if ( iSel == 0 )
				{
					m_errno = SELECT_TIMEOUT;
					return( NULL );
				}
				
				if ( ( iSel == -1 ) && ( errno == EINTR ) )
				{
					m_errno = SELECT_TRYAGAIN;
					return( NULL );				
				}
				
				// find out wich one is ready
				for( unsigned int i = 0; i < size(); i++ )
				{
					T *pcSock = (*this)[i];
					int & iSock = pcSock->GetSock();
					
					if ( TFD_ISSET( iSock, &wfds ) )
					{
						if ( iSel > 0 )
						{
							m_errno = SUCCESS;
							if ( !pcSock->hasWrite() )
							{
								pcSock->setWrite( true );
								// Call the Connected Event
								pcSock->Connected();
							}
							// write whats in the socks send buffer
							if ( !pcSock->GetSendBuff().empty() )
								if ( !pcSock->Write( "" ) )
									DestroySock( pcSock );	// write failed, sock died :(
								
						} else
							m_errno = SELECT_ERROR;

						return( pcSock );

					} else if ( TFD_ISSET( iSock, &rfds ) )
					{
						if ( iSel > 0 )
							m_errno = SUCCESS;
						else
							m_errno = SELECT_ERROR;

						return( pcSock );
					}						
				}
				// it said one was ready, but none of them were :(
				m_errno = SELECT_ERROR;	
				return( NULL );
			}
			
			return( NULL );
		}			
				
		void DelSock( T *pcSock )
		{
			typename vector<T *>::iterator p;
			
			for( unsigned int i = 0; i < size(); i++ )
			{
				if ( (*this)[i] == pcSock )
				{
					// clean up
					(*this)[i]->Disconnected();
					
					p = this->begin() + i;
					Zzap( (*this)[i] );
					this->erase( p );
					return;
				}
			}
			cerr << "WARNING!!! Could not find " << (unsigned int *)pcSock << endl;
		}


		//
		// Best place to call this class for running, all the call backs are called
		// You should through this in your main while loop (long as its not blocking)
		// 
		void Loop ()
		{
			T *pcSock = Select();
			
			switch( m_errno )
			{
				case SUCCESS:
				{
					pcSock->ResetTimer();	// reset the timeout timer
					
					// read in data
					char buff[64];
					int bytes = pcSock->Read( buff, 64 );

					switch( bytes )
					{
						case 0:
						{
							// EOF
							DelSock( pcSock );
							break;
						}
						
						case -1:
						{
							pcSock->SockError();
							DelSock( pcSock );
							break;
						}
						
						case -2:
							break;
							
						default:
						{
							pcSock->PushBuff( buff, bytes );
							pcSock->ReadData( buff, bytes );
							break;
						}								
					}
					break;
				}
			
				case SELECT_ERROR:
				{
					// a socket came back with an error
					// usually means it was closed
					DelSock( pcSock );
					break;
				}
				
				case SELECT_TIMEOUT:
				{
					// call timeout on all the sockets
					for( unsigned int i = 0; i < size(); i++ )
					{
						if ( (*this)[i]->GetType() != T::LISTENER )
						{
							if ( (*this)[i]->CheckTimeout() )
							{
								DestroySock( (*this)[i] );
							}
						}
					}
					break;
				}

				default	:
					break;
			}

			// run any Manager Crons we may have
			Cron();
		}

		//
		// Make this method virtual, so you can override it when a socket is added
		// Assuming you might want to do some extra stuff
		virtual void AddSock( T *pcSock, const Cstring & sSockName )
		{
			pcSock->SetSockName( sSockName );
			push_back( pcSock );
		}
		
		T * FindSockByName( const Cstring & sName )
		{
			for( unsigned int i = 0; i < size(); i++ )
				if ( (*this)[i]->GetSockName() == sName )
					return( (*this)[i] );
			
			return( NULL );
		}
		
		vector<T *> FindSocksByRemoteHost( const Cstring & sHostname )
		{
			vector<T *> vpSocks;
			
			for( unsigned int i = 0; i < size(); i++ )
				if ( (*this)[i]->GetHostName() == sHostname )
					vpSocks.push_back( (*this)[i] );
			
			return( vpSocks );
		}
		
		int GetErrno() { return( m_errno ); }
		void DestroySock( T * pcClass ) { m_pcDestroySocks.push_back( pcClass ); }
		
		
		void AddCron( CCron *pcCron )
		{
			m_vcCrons.push_back( pcCron );
		}

		//
		// these crons get ran in Loop()
		void Cron()
		{
			vector<CCron *>::iterator p = m_vcCrons.begin();

			while( true )
			{
				if ( p == m_vcCrons.end() )
					break;
					
				CCron *pcCron = *p;

				if ( !pcCron->isValid() )
				{
					Zzap( pcCron );
					m_vcCrons.erase( p );
					// start from the beginning again
					p = m_vcCrons.begin();
					
				} else
				{
					pcCron->run();
					p++;
				}
			}
		}		

private:

		int				m_errno;
		vector<T *>		m_pcDestroySocks;
		vector<CCron *>		m_vcCrons;
};

#endif /* _HAS_CSOCKET_ */

