#ifndef _HAS_CSOCKET_
#define _HAS_CSOCKET_
#include <stdio.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/fcntl.h>
#include <sys/file.h>
#include <netinet/in.h>
#include <stdlib.h>
#include <netdb.h>
#include <errno.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

#ifdef _HAS_SSL
#include <openssl/ssl.h>
#include <openssl/err.h>
#endif /* _HAS_SSL */

#include <Cstring>
#include <Cthreads>

// wrappers for FD_SET and such to work in templates

void TFD_ZERO( fd_set *set )
{
	FD_ZERO( set );
}

void TFD_SET( int iSock, fd_set *set )
{
	FD_SET( iSock, set );
}

bool TFD_ISSET( int iSock, fd_set *set )
{
	if ( FD_ISSET( iSock, set ) )
		return( true );
		
	return( false );
}

class Csock
{
public:
		Csock( const Cstring & sHostname, int iport, int itimeout = 60 ) 
		{
#ifdef _HAS_SSL	
			m_ssl = NULL;
			m_ssl_ctx = NULL;
#endif /* _HAS_SSL */		
			m_isock = 0;
			m_itimeout = itimeout;
			m_bssl = false;
			m_bhaswrite = false;
			m_iport = iport;
			m_shostname = sHostname;
			m_bNeverWritten = true;
		}
	
		virtual ~Csock()
		{
			close( m_isock );
#ifdef _HAS_SSL		
			if ( m_ssl )
			{
				SSL_shutdown( m_ssl );
				SSL_free( m_ssl );
			}
										
			if ( m_ssl_ctx )
				SSL_CTX_free( m_ssl_ctx );
			
			m_ssl = NULL;
			m_ssl_ctx = NULL;
#endif /* _HAS_SSL */				
		}

		bool Resolve()
		{
			char hbuff[2048];
			memset( (char *)hbuff, '\0', 2048 );
			
			int err;
			
			if ( gethostbyname_r( m_shostname.c_str(), &m_hentbuff, hbuff, 2048, &m_hent, &err ) != 0 )
				return( false );
			
			return( true );
			
		}

		bool Connect()
		{
			// create the socket
			m_isock = socket( PF_INET, SOCK_STREAM, IPPROTO_TCP );
				
			m_address.sin_family = PF_INET;
			m_address.sin_port = htons( m_iport );
			m_address.sin_addr = *(struct in_addr *)m_hent->h_addr;
			
			// set it none blocking
			int fdflags = fcntl (m_isock, F_GETFL, 0);
			fcntl( m_isock, F_SETFL, fdflags|O_NONBLOCK );
			
			// connect
			connect( m_isock, (struct sockaddr *)&m_address, sizeof( m_address ) );
			if ( errno != EINPROGRESS )
				return( false );
			
			return( true );
		}
#ifdef _HAS_SSL
	
		bool ConnectSSL( int method = 0 )
		{
			m_bssl = true;

			SSLeay_add_ssl_algorithms();
	
			switch( method )
			{
				case 0:
					m_ssl_method = SSLv23_client_method();
					if ( !m_ssl_method )
					{
						cerr << "WARNING: MakeConnection .... SSLv23_client_method failed!" << endl;
						return( false );
					}
					break;
		
				case 2:
					m_ssl_method = SSLv2_client_method();
					if ( !m_ssl_method )
					{
						cerr << "WARNING: MakeConnection .... SSLv2_client_method failed!" << endl;
						return( false );
					}
					break;
		
				case 3:
					m_ssl_method = SSLv3_client_method();
					if ( !m_ssl_method )
					{
						cerr << "WARNING: MakeConnection .... SSLv3_client_method failed!" << endl;
						return( false );
					}		
					break;
			
				default:
					cerr << "WARNING: MakeConnection .... invalid http_sslversion version!" << endl;
					return( false );
					break;
			}

			SSL_load_error_strings ();
			// wrap some warnings in here
			m_ssl_ctx = SSL_CTX_new ( m_ssl_method );
			if ( !m_ssl_ctx )
				return( false );
			
			m_ssl = SSL_new ( m_ssl_ctx );
			if ( !m_ssl )
				return( false );
			
			SSL_set_fd( m_ssl, m_isock );
	
			if ( ( SSL_connect( m_ssl ) < 0 ) && ( errno != EAGAIN ) )
				return( false );

			return( true );
		}

		//
		// Write to the socket
		//
		bool Write( const char *data, int len )
		{
			// I know this seems silly, but if you setup string right, it can handle binary data
			// and ultimatly its easier to work with
			Cstring sSend;
			sSend.append( data, len );
			m_bNeverWritten = false;
#ifdef _HAS_SSL		
			if ( m_bssl )
			{
				bool bLoop = true;
				while ( bLoop )
				{
					int iErr = SSL_write( m_ssl, sSend.c_str(), sSend.length() );
					switch( SSL_get_error( m_ssl, iErr ) )
					{
						case SSL_ERROR_NONE:
						// all ok
						bLoop = false;
						break;
				
						case SSL_ERROR_ZERO_RETURN:
						// weird closer alert
						return( false );
						break;
				
						case SSL_ERROR_WANT_READ:
						// retry
						break;
				
						case SSL_ERROR_WANT_WRITE:
						// retry
						break;
					}
				}			
				return( true );
			}
#endif /* _HAS_SSL */
			while ( true )
			{
				int bytes = write( m_isock, sSend.c_str(), sSend.length() );
			
				if ( ( bytes <= 0 ) && ( errno != EAGAIN ) )
				{
					return( false );
					break;
				}
				
				if ( (unsigned int)bytes < sSend.length() )
				{
					// only able to write part, write the rest
					sSend.erase( 0, bytes );
			
				} else
					break;
			}
			
			return( true );
		}
		
		//
		// Write to the socket
		//	
		bool Write( const Cstring & sData )
		{
			return( Write( sData.c_str(), sData.length() ) );
		}

		//
		// Read from the socket
		// Just pass in a pointer, big enough to hold len bytes
		//
		// Returns 0 for EOF
		// Returns -1 for ERROR
		// Returns -2 for Try Again ( EAGAIN )
		// Otherwise returns the bytes read into data
		//
		int Read( char *data, int len )
		{
			int bytes = 0;
			memset( (char *)data, '\0', len );
			
#ifdef _HAS_SSL							
			if ( m_bssl )							
				bytes = SSL_read( m_ssl, data, len );
			else
#endif /* _HAS_SSL */							
				bytes = read( m_isock, data, len );
			
			if ( bytes == 0 )
			{
			 	if ( errno != EAGAIN )
					return( 0 );
				else
					return( -2 );
					
			} else if ( bytes == -1 )
			{
				if ( ( errno == EINTR ) || ( errno != EAGAIN ) )
					return( -2 );
#ifdef _HAS_SSL
				if ( m_bssl )
				{
					int iErr = SSL_get_error( m_ssl, bytes );
					if ( ( iErr != SSL_ERROR_WANT_READ ) && ( iErr != SSL_ERROR_WANT_WRITE ) )
						return( -1 );
					else
						return( -2 );
				}
#else
				return( -1 );
#endif /* _HAS_SSL */								
			}
			
			return( bytes );
		}

		//
		// misc functions
		//				
		bool hasWrite() { return( m_bhaswrite ); }
		void setWrite( bool b ) { m_bhaswrite = b; }	
		
		int & GetSock() { return( m_isock ); }

		bool needsWrite()
		{
			return( m_bNeverWritten );
		}
		
		//
		// Override these functions for an easy interface
		// They do nothing yet
		virtual void Connected() {}
		virtual void Disconnected() {}
		virtual void ReadData( const char *data, int len ) {}
		virtual void ReadLine( const Cstring & sLine ) {}
		
		//////////////////////////////////////////////////	
			
#endif /* _HAS_SSL */				
private:
		int			m_isock, m_itimeout, m_iport;
		bool		m_bssl, m_bhaswrite, m_bNeverWritten;
		Cstring		m_shostname;

		struct hostent		*m_hent, m_hentbuff;
		struct sockaddr_in 	m_address;
		
#ifdef _HAS_SSL
		SSL 				*m_ssl;
		SSL_CTX				*m_ssl_ctx;
		SSL_METHOD			*m_ssl_method;
#endif /* _HAS_SSL */	

};

//
// new it and forget it
//
template<class T>
class TConn : public vector<T *>
{
public:
		TConn() {}
		virtual ~TConn() {}

		typedef enum
		{
			SUCCESS		= 0,
			HOST_ERR 	= 1,
			CONNECT_ERR = 2,
			SSL_ERR		= 3,
			REFUSED_ERR	= 4,
			SELECT_ERR	= 5
			
		} eMessages;

		virtual bool Connect( const Cstring & sHostname, int iPort , bool isSSL = false )
		{
			// create the new object
			T *pcSock = new T( sHostname, iPort );
			
			// figure out the hostname we're connecting to.		
			if ( !pcSock->Resolve() )
			{
				delete( pcSock );
				return( false );
			}
			
			if ( !pcSock->Connect() )
			{
				delete( pcSock );
				return( false );
			}
	
			if ( isSSL )
			{
				if ( !pcSock->ConnectSSL() )
				{
					delete( pcSock );
					return( false );
				}
			}
			
			push_back( pcSock );
			return( true );
		}
		
		//
		// returns a pointer to the ready Csock class thats available
		// returns NULL if none are ready, check getErr() for the error, if not SUCCESS Select() failed
		//
		
		T * Select( int iTime_sec = 1, int iTime_usec = 0 )
		{		
			struct timeval tv;
			fd_set rfds, wfds;
			
			tv.tv_sec = iTime_sec;	// one second timeout, good for clocks
			tv.tv_usec = iTime_usec;
		
			TFD_ZERO( &rfds );						
			TFD_ZERO( &wfds );
			
			bool bHasWriteable = false;
			
			for( unsigned int i = 0; i < size(); i++ )
			{
				Csock *pcSock = (*this)[i];
				int & iSock = pcSock->GetSock();

				if ( pcSock->hasWrite() )
				{
					TFD_SET( iSock, &rfds );
					
				} else
				{
					TFD_SET( iSock, &rfds );
					TFD_SET( iSock, &wfds );
					bHasWriteable = true;
				}

			}
			
			// now select on them
			while( true )
			{
				int iSel;
				 
				if ( bHasWriteable )
					iSel = select(FD_SETSIZE, &rfds, &wfds, NULL, &tv);
				else
					iSel = select(FD_SETSIZE, &rfds, NULL, NULL, &tv);
				
				if ( iSel == 0 )
				{
					m_errno = SUCCESS;
					return( NULL );
				}
				
				if ( ( iSel == -1 ) && ( errno != EINTR ) )
				{
					m_errno = SELECT_ERR;
					return( NULL );
				
				}
				
				if ( iSel > 0 )
				{
					// find out wich one is ready
					for( unsigned int i = 0; i < size(); i++ )
					{
						Csock *pcSock = (*this)[i];
						int & iSock = pcSock->GetSock();
						
						if ( TFD_ISSET( iSock, &rfds ) )
							return( pcSock );
						else if ( TFD_ISSET( iSock, &wfds ) )
						{
							pcSock->setWrite( true );
							return( pcSock );
						}

					}
					
					// it said one was ready, but none of them were :(
					m_errno = SELECT_ERR;	
					return( NULL );
				}
			}
			
			return( NULL );
		}			
				
		void DelSock( T *pcSock )
		{
			vector<T *>::iterator p;
			
			for( unsigned int i = 0; i < size(); i++ )
			{
				if ( (*this)[i] == pcSock )
				{
					p = this->begin() + i;
					delete( (*this)[i] );
					this->erase( p );
					return;
				}
			}
			cerr << "WARNING!!! Could not find " << (unsigned int *)pcSock << endl;
		}

		int getErr() { return( m_errno ); }
private:

		int			m_errno;
};

#endif /* _HAS_CSOCKET_ */